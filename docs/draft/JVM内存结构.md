## 共有部分：Java堆、方法区、常量池
Java 堆根据对象存活时间的不同，Java 堆还被分为年轻代、老年代两个区域，年轻代还被进一步划分为 Eden 区、From Survivor 0、To Survivor 1 区。如下图所示。
![](https://harvies-oss.oss-cn-hangzhou.aliyuncs.com/2020/10/14/20201014101000005-image.png)
在 JVM 中有一个名为 -XX:MaxTenuringThreshold 的参数专门用来设置晋升到老年代所需要经历的 GC 次数，即在年轻代的对象经过了指定次数的 GC 后，将在下次 GC 时进入老年代。
## 私有部分：PC寄存器、Java 虚拟机栈、本地方法栈

### PC(Program Counter) 寄存器
PC 寄存器，顾名思义 Program Counter 寄存器，指的是保存线程当前正在执行的方法。
非native 方法，PC 寄存器就保存 Java 虚拟机正在执行的字节码指令地址。
native 方法，PC 寄存器保存的值是 undefined。
任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，而这个被线程执行的方法称为该线程的当前方法，其地址被存在 PC 寄存器中。

### Java 虚拟机栈
Java 虚拟机栈，这个栈与线程同时创建，用来存储栈帧，即存储局部变量与一些过程结果的地方。栈帧存储的数据包括：局部变量表、操作数栈。

### 本地方法栈
当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈。如果 Java 虚拟机不支持 native 方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈。
本地方法栈保存native方法栈帧
## 疑问

### 为什么 Java 堆要进行这样一个区域划分呢？
根据我们的经验，虚拟机中的对象必然有存活时间长的对象，也有存活时间短的对象，这是一个普遍存在的正态分布规律。如果我们将其混在一起，那么因为存活时间短的对象有很多，那么势必导致较为频繁的垃圾回收。而垃圾回收时不得不对所有内存都进行扫描，但其实有一部分对象，它们存活时间很长，对他们进行扫描完全是浪费时间。因此为了提高垃圾回收效率，分区就理所当然了。

### 为什么默认的虚拟机配置，Eden：from ：to = 8:1:1 呢？
其实这是 IBM 公司根据大量统计得出的结果。根据 IBM 公司对对象存活时间的统计，他们发现 80% 的对象存活时间都很短。于是他们将 Eden 区设置为年轻代的 80%，这样可以减少内存空间的浪费，提高内存空间利用率。


## 参考
https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html