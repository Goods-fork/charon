### 乐观锁悲观锁试用场景?

悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

### java面试题之什么是死锁、活锁、饿死和竞态条件？

死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力作用，他们将无法推进下去；

活锁：是指两个线程优先级相同，都礼让不走，就这样一直僵持下去；

饿死：在单线程情况下，A、B两个线程，A先执行；A在执行过程中，C线程来了，B让C先执行；C在执行过程中，D线程来了，B也让D先执行，就这样B一直都是等待状态。

竞态条件：多个线程竞争同一个变量，导致数据的不正确性，线程的访问顺序是不可控的，会影响最终的结果。

#### 产生死锁的必要条件：

1、互斥使用（资源独占）

　　一个资源每次只能给一个进程使用（比如写操作）

2、占有且等待：

　　进程在申请新的资源的同时，保持对原有资源的占有

3、不可抢占：

　　资源申请者不能强行从资源占有者手动夺取资源，资源只能由占有者自愿释放

4、循环等待：

　　A等待B占有的资源，B等待C占有的资源，C等待D占有的资源，..........N等待A的资源，形成一个线程等待回路

### stop() 和 suspend() 方法为何不推荐使用？
反对使用 stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。
suspend() 方法容易发生死锁。调用 suspend() 的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被 "挂起" 的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 suspend()，而应在自己的 Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait() 命其进入等待状态。若标志指出线程应当恢复，则用一个 notify() 重新启动线程。

### sleep() 和 wait() 有什么区别?
1.sleep()不会释放当前占有的锁,sleep(long)会导致

2.sleep()线程进入 TIMED-WATING 状态,而 wait()方法会导致当前线程进入 WATING 状态

~~sleep 就是正在执行的线程主动让出 cpu，cpu 去执行其他线程，在 sleep 指定的时间过后，cpu 才会回到这个线程上继续往下执行，
如果当前线程进入了同步锁，sleep 方法并不会释放锁，即使当前线程使用 sleep 方法让出了 cpu，但其他被同步锁挡住了的线程也无法得到执行。
wait 是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了 notify 方法（notify 并不释放锁，
只是告诉调用过 wait 方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果 notify 方法后面的代码还有很多，
需要这些代码执行完后才会释放锁，可以在 notfiy 方法后增加一个等待和一些代码，看看效果），调用 wait 方法的线程就会解除 wait 状态和程序可以再次得到锁后继续向下运行。~~

### 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?
其他方法前是否加了 synchronized 关键字，如果没加，则能。
如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。
如果其他个方法都加了 synchronized 关键字，并且内部没有调用 wait，则不能。
如果其他方法是 static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是 this。

### 多线程中的忙循环是什么?
忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。
在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。

### volatile 变量是什么？volatile 变量和 atomic 变量有什么不同？
volatile 则是保证了所修饰的变量的可见。因为 volatile 只是在保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量，即 Boolean 类型的变量。
volatile 多用于修饰类似开关类型的变量、Atomic 多用于类似计数器相关的变量、其它多线程并发操作用 synchronized 关键字修饰。
volatile 有两个功用：
这个变量不会在多个线程中存在复本，直接从内存读取。
这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。

### volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？
volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。
在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时，如果使用 volatile 关键字，就会获到（简单的赋值与返回操作的）原子性。
