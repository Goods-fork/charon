## 促销项目使用MQ的好处
###  异步
> 使用场景：（还未使用）目前活动列表能自动显示已被删除的商品，使用的是异步的方式，用户点击活动列表（此处还使用了懒加载的思想），则后台会扫描活动列表里所有的商品，
>与商品服务里的商品状态做对比，如已被删除则更新促销活动里该商品的状态。目前使用的是内存队列存储活动列表查询任务，如果发版时队列里还有数据则会丢失，
>可使用MQ来存储
###  解耦
> 使用场景：淘宝ONS消息推送过来，我们将该消息发送我们自己的MQ，
>商品服务订阅该消息更新数据库商品信息
>促销服务订阅该消息实现自动给参与全店满减活动的商品投放满减海报
>如果不使用MQ,则需要在接收淘宝ONS消息的地方调用商品服务更新数据库，调用促销服务投放海报，
>如果其他地方（例如如果素材模板服务新增了一个全店打水印的需求）也需要接收淘宝ONS上下架消息，
>则有需要修改接收淘宝ONS消息这里的逻辑，这样就是耦合在一起了
###  削锋
> 使用场景：促销活动添加宝贝时，多个消费者使用集群模式（clustering，默认）同时处理，
>大促来临时，创建促销活动的请求比较多，此时只需要新增消费者（docker里只需要修改实例即可弹性扩容）即可加快处理速度
>如果不使用MQ,则只能临时升级服务器，升级服务器需要停机

### 解决发版导致的任务中断
> 使用场景:在添加宝贝任务时，任务还在执行中，系统发版导致执行中断，页面就会一直显示处理中，
> 我们采用MQ的延迟消息来解决这个问题，每添加一个宝贝时，向MQ发送一条延迟消息，延迟消息收到后，检查数据库状态，
> 如果还是处理中，则改为失败，让用户在页面重试
> 如果不用MQ,则需要采用扫数据库的方式，该方式效率低，延迟高(数据量越大，轮询时间越长，延迟也就越长)

## 消息队列的缺点
1. 系统可用性降低 
> MQ挂了咋办？整个系统全崩了
2. 系统复杂度提高
- 怎么保证消息不重复消费？
> 消息重复的原因可能是:producer发送消息到broker时，由于网络原因会重新发送到broker
> 应用层使用消息时更新下数据库状态（乐观锁），若状态不一致则丢弃
- 消息丢失了怎么办？
> MQ层面:有消息重试和消息重投策略
>消息重试:Consumer在消费时异常情况下，broker会再次推送给Consumer,活动Consumer可再次从broker拉取消息
>消息重投: Producer在发送消息到broker时，由于网络等原因会重新发送消息到broker
> https://github.com/apache/rocketmq/blob/master/docs/cn/features.md
>
> 应用层面:针对安全性较高的数据，可以采用消息先入数据库，再发消息到MQ的方案，MQ丢了可以从数据库恢复
- 如何保证消息顺序性？
> 普通顺序消息:发送和消费走同一个队列，例如同一个订单号对应的创建，付款，推送，完成走同一队列（按订单号取模）
> 严格顺序消息:消费者收到的所有消息均是有顺序的。
3. 一致性问题
> 异步返回给用户成功，后端几个服务有失败咋整？
>举例：话费充值系统，下游找我们下单，我们返回给用户下单成功，需要告诉下游仅仅是下单成功，我们再请求上游系统去充值，
>充值成功后，我们采用回调的方式通知下游，订单成功
>总结：文案一定要准确，处理成功字样是有歧义的，一定要分清是下单成功还是订单处理成功

## RocketMQ延迟消息实现原理
> 定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，
>即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。
> 需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。
> https://github.com/apache/rocketmq/blob/master/docs/cn/features.md
